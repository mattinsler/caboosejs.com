<% page = 'your-first-app' %>

<section class="heading">
  <h1>Your First App</h1>
  <p>
    Let's make a simple single-user blog.  We'll use <a href="http://www.mongodb.org">MongoDB</a> to store
    blog posts and basic HTTP authentication to edit our blog posts.
  </p>
  <hr />
</section>

<section>
  <h2>Dependencies</h2>
  <p>
    If you don't have <a href="http://nodejs.org/">Node 6.x</a> installed, this would be the time to install it.
    Don't worry, I'll wait...  OK, now you'll need two things, <a href="http://www.mongodb.org">MongoDB</a>, <a href="http://www.mongodb.org/display/DOCS/Quickstart">which you can install and start with instructions here</a>,
    and the caboose module, which you can install like this:
  
    <script src="https://gist.github.com/1610730.js"> </script>
  </p>
</section>

<section>
  <h2>Create the application</h2>
  <p>
    First, let's create a new caboose application.  Running <code>caboose create</code> will create a new directory
    and fill it with the initial files for a caboose stack.
  
    <script src="https://gist.github.com/1613471.js?file=gistfile1.sh"></script>
  </p>
</section>

<section>
  <h2>Install caboose-model</h2>
  <p>
    The <a href="/plugins/caboose-model">caboose-model</a> plugin is a simple MongoDB model layer.  It tries to give the
    feel of working in the MongoDB Shell.  Plugins can be installed easily with the <code>caboose plugin install</code>
    command.  This command will locally install the <a href="/plugins/caboose-model">caboose-model</a> module using
    <a href="http://npmjs.org/">npm</a> and configure your project to use the plugin.
  
    <script src="https://gist.github.com/1615356.js"> </script>
  </p>
  <p>
    Let's look at what caboose plugin install does.  Your <code>package.json</code> should look like this now:
  
    <script src="https://gist.github.com/1618985.js"> </script>
  </p>
  <p>
    The plugin install script will add the current version of the npm module to your dependencies and then append
    the plugin name to the <code>caboose-plugins</code> array.  Caboose uses uses the caboose-plugins
    array in your package.json to determine which plugins to load and the order in which to load them.  It's important
    to realize that the load order of plugins can be important.  For instance, if a plugin alters model definitions,
    like <a href="/plugins/caboose-authentication">caboose-authentication</a> does, then caboose-model needs to be
    loaded before caboose-authentication.
  </p>
</section>

<section>
  <h2>Create the Post model</h2>
  <p>
    Let's create the Post model.  This will hold the content and metadata of our blog posts.  We're going to use the
    <code>caboose model new</code> command to do this, which creates a basic model in coffeescript.  You never need to
    use this command line helper, but it's nice when you forget.
  
    <script src="https://gist.github.com/1619742.js"> </script>
  </p>
  <p>
    So what does that basic model look like?  If we open up app/models/user.coffee now, we should see
  
    <script src="https://gist.github.com/1619757.js"> </script>
  </p>
  <p>
    All models must extend <code>Model</code>, which provides the basic functionality you'd expect from a MongoDB
    model.  We'll get more into that later...  For now, we can see that there's a model named User defined.  The
    <code>store_in</code> method tells caboose-model to store all User objects in the collection named user.
  </p>
  <p>
    That's all that we need!  Model objects don't need to be defined up front.  They basically act like a MongoDB object
    does in the shell.  You can add any data you want.
  </p>
</section>

<section>
  <h2>Create the posts route</h2>
  <p>
    We're creating a resource here, so let's use a <code>resource</code> route.  Open up the config/routes.coffee
    file and let's add  <code>@resources 'posts'</code> to it.
  
    <script src="https://gist.github.com/1619919.js"> </script>
  </p>
  <p>
    Resource routes create 7 actions: <code>index</code>, <code>new</code>, <code>create</code>, <code>show</code>,
    <code>edit</code>, <code>update</code> and <code>destroy</code>.  In this case, that creates the following routes:
  
    <table>
      <thead>
        <th>Action</th>
        <th>Method</th>
        <th>Path</th>
      </thead>
      <tbody>
        <tr>
          <td>index</td>
          <td>GET</td>
          <td>/posts</td>
        </tr>
        <tr>
          <td>new</td>
          <td>GET</td>
          <td>/posts/new</td>
        </tr>
        <tr>
          <td>create</td>
          <td>POST</td>
          <td>/posts</td>
        </tr>
        <tr>
          <td>show</td>
          <td>GET</td>
          <td>/posts/:id</td>
        </tr>
        <tr>
          <td>edit</td>
          <td>GET</td>
          <td>/posts/:id/edit</td>
        </tr>
        <tr>
          <td>update</td>
          <td>PUT</td>
          <td>/posts/:id</td>
        </tr>
        <tr>
          <td>destroy</td>
          <td>DELETE</td>
          <td>/posts/:id</td>
        </tr>
      </tbody>
    </table>
  </p>
</section>

<section>
  <h2>Create the Posts controller</h2>
  <p>
    OK, so no command line helper here.  I know, I know.  I'll get around to it.  Anyway, to create the new controller,
    make a new file called posts_controller.coffee in the app/controllers directory.  Here is a very basic controller
    to show and manipulate the Post resource.
  
    <script src="https://gist.github.com/1619786.js"> </script>
  </p>
  <p>
    Let's break this down a bit.  All controllers eventually extend <code>Controller</code>, be it directly or through
    other controllers.  In this case, we extend Controller directly.  Since we're implementing a resourceful route, there are
    the above 7 possible actions.  We're going to leave out destroy for now, because we're friendly people and destroying
    is such a negative thing.
  </p>
  <p>
    As you can see in the route table, show, edit and update have a parameter in the route, :id.  This means that
    when each of those actions are called, the id parameter will be filled in with a value from the URL.  These route paramters
    are accessible via the <code>@params</code> object within the controller.  For instance, the show method could look like this:
  
    <script src="https://gist.github.com/1619968.js"> </script>
  </p>
  <p>
    When someone goes to the URL at /posts/12345, this will print 12345 to the console and then render.
  </p>
</section>
