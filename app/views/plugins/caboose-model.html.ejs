<% page = 'caboose-model' %>

<section class="heading">
  <h1>Caboose Model</h1>
  <p>
    caboose-model is a <a href="http://www.mongodb.org/">MongoDB</a> model library for <a href="http://www.caboosejs.com">caboose</a>.
    It uses <a href="https://github.com/christkv/node-mongodb-native">node-mongodb-native</a> as the underlying driver.
  </p>
  <hr />
</section>

<section>
  <h2>Installation</h2>
  <p>
    To install caboose-model, use the <code>caboose plugin install</code> command.
    
    <%- highlight_start('bash') %>
$ caboose plugin install caboose-model
    <%- highlight_end() %>
  </p>
</section>

<section id="configuration">
  <h2>Configuration</h2>
  <p>
    After installation, there will be a caboose-model.json file in your config directory.  This file holds the configuration for
    connecting to MongoDB.  The initial value should look something like this.
    
    <%- highlight_start('javascript') %>
{
  "host": "localhost",
  "port": 27017,
  "database": "new-app"
}
    <%- highlight_end() %>
  </p>
  <p>
    This should be fine for a while, but eventually you'll need to deploy your app to a server, like <a href="http://www.heroku.com/">Heroku</a>.
    When this happens, just move that caboose-model.json file into one of the config/environments directories.
  </p>
  <p>
    You can also specify just the <code>url</code>.
    
    <%- highlight_start('javascript') %>
{
  "url": "mongodb://user:pass@server:port/database"
}
    <%- highlight_end() %>
  </p>
  <p>
    Alternatively (for situations such as Heroku), you can use the config/application.coffee or config/environments/[env].coffee files
    to set the model configuration like this.
    
    <%- highlight_start('coffeescript') %>
module.exports = (config, next) ->
  config['caboose-model'] =
    url: process.env.MONGOHQ_URL

  next()
    <%- highlight_end() %>
  </p>
</section>

<section>
  <h2>Definition</h2>
  <p>
    Models can simply be defined in coffeescript by extending the <code>Model</code> class.  Here is the basic model that
    <code>caboose generate model Post</code> will create.
    
    <%- highlight_start('coffeescript') %>
class Post extends Model
  store_in 'post'
    <%- highlight_end() %>
  </p>
  <p>
    Models have attributes and methods.
  </p>
  <p>
    Attributes generally describe the model class.  So above we have a model named <code>Post</code>
    which should located in the app/models/post.coffee file and will store instances of itself in the <code>post</code> collection.  There are a
    variety of <a href="#supported_attributes">attributes</a> you can add a model, which can change it's behavior.
  </p>
  <p>
    Methods are actually just an <code>instance</code> attribute with syntactic sugar.  All class methods you define in your model class will
    just become methods of the model class, like you'd expect.
  </p>
  <p>
    Here's a more complex model to illustrate some of what you can do.
    
    <%- highlight_start('coffeescript') %>
import 'StringHelper'

class Post extends Model
  store_in 'post'

  static 'latest_timestamp', (callback) ->
    @sort({posted_at: -1}).fields({posted_at: 1}).first (err, post) ->
      return callback(err) if err?
      callback err, post.posted_at

  summary: ->
    StringHelper.summarize(@content)
    <%- highlight_end() %>
  </p>
  <p>
    In the above example, we first import in functionality of the <code>StringHelper</code> (the <code>import</code> method is described <a href="#">here</a>)
    which we will use in the summary method.
  </p>
  <p>
    Then we define the Post model and store it in the post collection just like the generated model.
  </p>
  <p>
    Next we add a class method named <code>latest_timestamp</code> to the model.  Class methods are defined with the <code>static</code> attribute and
    are a great way to add shortcut methods like this.  In this case, we could just call <code>Post.latest_timestamp(...)</code> rather than writing
    out all the query code in a controller.  It's important to realize that latest_timestamp will not be available from instances.  So
    <code>new Post().latest_timestamp(...)</code> would not work.
  </p>
  <p>
    Finally we add an instance method named <code>summary</code> which uses the StringHelper to provide a summary of the content of the post.  The
    summary method could have also been defined as
    
    <%- highlight_start('coffeescript') %>
instance 'summary', ->
  StringHelper.summarize(@content)
    <%- highlight_end() %>
  </p>

  <section id="supported_attributes">
    <h3>Supported attributes</h3>
    <p>
      <code><strong>store_in(collection name)</strong></code> the collection to persist this model to<br>
      <code><strong>instance(method_name, method)</strong></code> a method to be added to the model prototype<br>
      <code><strong>static(method_name, method)</strong></code> a method to be added to the model, not available to instances<br>
    </p>
  </section>
</section>

<section id="finders">
  <h2>Finders</h2>
  <p>
    These methods will retrieve records or metadata from the database and should be the last method you call in a query.
  </p>

  <section>
    <h3>first(callback)</h3>
    <p>
      Fetches the first record in the current query.
      
      <%- highlight_start('coffeescript') %>
# Retrieve the first Post object
Post.first (err, post) ->
  # post is either null or a Post object

# Retrieve the first Post object in the query
Post.where(...).first (err, post) ->
  # post is either null or a Post object
      <%- highlight_end() %>
    </p>
  </section>
  
  <section>
    <h3>array(callback)</h3>
    <p>
      Fetches all the records in the current query as an array.
      
      <%- highlight_start('coffeescript') %>
# Retrieve all Post objects
Post.array (err, posts) ->
  # posts is either [] or an array of Post objects

# Retrieve all Post objects in the query
Post.where(...).array (err, posts) ->
  # posts is either [] or an array of Post objects
      <%- highlight_end() %>
    </p>
  </section>
  
  <section>
    <h3>each(callback)</h3>
    <p>
      Fetches all the records in the current query and calls the callback one record at a time.  When there are no
      more records, a null will be passed to the callback for both the error and item.
    </p>
    <p>
      <strong>NOTE:</strong> Even if there are no records in the collection, the callback will be invoked once with
      nulls for both arguments.
      
      <%- highlight_start('coffeescript') %>
# Retrieve all Post objects one at a time (streaming)
Post.each (err, post) ->
  # if there are no more posts, post is null
  # otherwise, post is a Post object

# Retrieve all Post objects one at a time (streaming) in the query
Post.where(...).each (err, post) ->
  # if there are no more posts, post is null
  # otherwise, post is a Post object
      <%- highlight_end() %>
    </p>
  </section>
  
  <section>
    <h3>count(callback)</h3>
    <p>
      Counts the records in the current query.
      
      <%- highlight_start('coffeescript') %>
# Counts the records in the post collection
Post.count (err, count) ->
  console.log "There are #{count} post(s)."

# Filters and counts the records in the post collection
Post.where(...).count (err, count) ->
  console.log "There are #{count} filtered post(s)."
      <%- highlight_end() %>
    </p>
  </section>
  
  <section>
    <h3>distinct(key, callback)</h3>
    <p>
      Collects the distinct values for <code>key</code>.
      
      <%- highlight_start('coffeescript') %>
# Collect the distinct titles from all posts
Post.distinct 'title', (err, titles) ->
  # titles is an array of the distinct post titles

# Collect the distinct titles from all posts in the query
Post.where(...).distinct 'title', (err, titles) ->
  # titles is an array of the distinct post titles in the query
      <%- highlight_end() %>
    </p>
  </section>
</section>

<section id="modifiers">
  <h2>Modifiers</h2>
  <p>
    These methods modify the records returned by the above <a href="#finders">finders</a>.  They return a query
    object that can be further modified or executed by a finder.
  </p>

  <section>
    <h3>skip(count)</h3>
    <p>
      Skips <code>count</code> records in the current query.
      
      <%- highlight_start('coffeescript') %>
# Skip the first 5 posts
Post.skip(5).first (err, post) ->
  # post is the sixth post

# Filter then skip the first 5 posts
Post.where(...).skip(5).first (err, post) ->
  # post is sixth post in this query
      <%- highlight_end() %>
    </p>
  </section>
  
  <section>
    <h3>limit(count)</h3>
    <p>
      Limits the current query to <code>count</code> records.
      
      <%- highlight_start('coffeescript') %>
# Retrieves the first 5 posts
Post.limit(5).array (err, posts) ->
  # posts is an array of Post objects

# Filter then retrieve the next 5 posts
Post.where(...).limit(5).array (err, posts) ->
  # posts is an array of Post objects
      <%- highlight_end() %>
    </p>
  </section>
  
  <section>
    <h3>sort(fields)</h3>
    <p>
      Sorts the records on the MongoDB side.
      
      <%- highlight_start('coffeescript') %>
# Retrieves all post records sorted by title descending
Post.sort({title: -1}).array (err, posts) ->
  # posts is an array of Post objects

# Filter then sort all posts by title ascending, created_at descending
Post.where(...).sort({title: 1, created_at: -1}).array (err, posts) ->
  # posts is an array of Post objects
      <%- highlight_end() %>
    </p>
  </section>
  
  <section>
    <h3>fields(fields)</h3>
    <p>
      Choose the fields to include or exclude.
      
      <%- highlight_start('coffeescript') %>
# Retrieve the first record
Post.fields({title: 1}).first (err, post) ->
  # Post object with only the _id and title fields

# Filter then retrieve the first record
Post.where(...).fields({title: 0}).array (err, posts) ->
  # Post object without the title field
      <%- highlight_end() %>
    </p>
  </section>
</section>

<section id="queries">
  <h2>Queries</h2>
  <p>
    Queries are written just like in the MongoDB Shell, only using the <code>where</code> method.
  </p>

  <section>
    <h3>where(query)</h3>
    <p>
      Filters the collection using any options that MonogDB supports.  There is little magic here.  You can use any
      JSON object that would work in the <code>find()</code> method on the MongoDB shell.  For more information on
      querying MongoDB, checkout <a href="http://www.mongodb.org/display/DOCS/Advanced+Queries">the docs</a>.
      
      <%- highlight_start('coffeescript') %>
# Find all posts authored by Matt Insler with
# tags caboose or mongodb
Post.where({
  author: 'Matt Insler',
  tags: {$in: ['caboose', 'mongodb']}
}).array (err, posts) ->
  # Post object without the title field
      <%- highlight_end() %>
    </p>
  </section>
</section>

<section id="actions">
  <h2>Actions</h2>
  <p>
    
  </p>
  
  <section>
    <h3>save(obj, callback = null)</h3>
    <p>
      
    </p>
  </section>
  
  <section>
    <h3>update(query, update, options, callback = null)</h3>
    <p>
    </p>
  </section>
  
  <section>
    <h3>update_multi(query, update, callback = null)</h3>
    <p>
    </p>
  </section>
  
  <section>
    <h3>upsert(query, update, callback = null)</h3>
    <p>
    </p>
  </section>
  
  <section>
    <h3>remove(query, callback = null)</h3>
    <p>
    </p>
  </section>
  
  <section>
    <h3>find_and_modify(options, callback)</h3>
    <p>
    </p>
  </section>
  
  <section>
    <h3>map_reduce(map, reduce, options, callback)</h3>
    <p>
    </p>
  </section>
</section>
